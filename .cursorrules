# Bandera Feature Flag Service - Cursor Rules

## üö® Git Operations - STRICT RULES

**CRITICAL: NEVER perform git operations without explicit user consent**

### Git Operation Rules - ULTRA STRICT
- **NEVER EVER** run `git add`, `git commit`, `git push`, or ANY git commands without EXPLICIT user permission
- **NEVER** automatically commit changes, even if they seem obvious or small
- **NEVER** assume permission from phrases like "let's commit" or "commit this"
- **ALWAYS** ask "Should I proceed with the git commands now?" before executing ANY git operation
- **REQUIRE** explicit confirmation like "yes", "go ahead", or "proceed" before running git commands
- **EVEN IF** the user says "let's commit everything" - ALWAYS ask for explicit confirmation first

### When user requests git operations:
1. **FIRST**: Ask "Should I proceed with running `git add .` and `git commit` now?"
2. **ONLY AFTER** explicit user confirmation: Execute the git commands
3. Write a comprehensive commit message covering ALL changes
4. Use conventional commit format with clear scope and description

### Forbidden Automatic Actions:
- ‚ùå Running git commands based on implied consent
- ‚ùå Assuming "commit" means "run git commands now"
- ‚ùå Executing git operations without asking "Should I proceed?"
- ‚úÖ ALWAYS require explicit "yes" before running git commands

### Commit Message Format
- Use conventional commits: `feat:`, `fix:`, `refactor:`, `docs:`, `test:`, etc.
- Include multi-line descriptions for complex changes
- Reference all affected components/files
- Explain the business value or technical improvement

---

## File Organization

### Directory Structure
- **Controllers**: `Sources/App/Controllers/` - All controller files end with `Controller`
- **Models**: `Sources/App/Models/` - Database entities and business models
- **Repositories**: `Sources/App/Repositories/` - Data access layer, end with `Repository`
- **Services**: `Sources/App/Services/` - Business logic layer, end with `Service`
- **Middleware**: `Sources/App/Middleware/` - Request/response processing
- **DTOs**: `Sources/App/DTOs/` - Data transfer objects and API models
- **View Templates**: `Resources/Views/` - Leaf templates with `.leaf` extension
- **Tests**: `Tests/AppTests/` - All test files end with `Tests`

---

## Naming Conventions

### Swift Naming Standards
- **Controllers**: End with `Controller` (e.g., `AuthController`)
- **Repositories**: End with `Repository` (e.g., `UserRepository`)
- **Services**: End with `Service` (e.g., `FeatureFlagService`)
- **Repository Protocols**: End with `RepositoryProtocol`
- **Service Protocols**: End with `ServiceProtocol`
- **View Templates**: Use `.leaf` extension
- **Test Files**: End with `Tests`

---

## Code Structure

### File Organization
- Use `// MARK: - Section Name` for major sections
- Place protocol conformances in extensions
- Group related properties and methods together
- Place private helpers in extensions at bottom of file
- Order: properties ‚Üí initializers ‚Üí public methods ‚Üí private methods

---

## Error Handling

### Error Management Patterns
- Define custom errors in dedicated `Errors.swift` files
- Custom errors must conform to `AbortError`
- Use `async/await` for asynchronous error handling
- Include recovery suggestions in error messages
- Log errors appropriately using `app.logger`
- Use the centralized `ErrorHandling` utility for consistent error responses

---

## Documentation

### Documentation Standards
- Use `///` for documentation comments
- Document all public APIs with parameter descriptions
- Include examples for non-obvious usage patterns
- Keep `README.md` updated with architectural changes
- Document configuration options and environment variables

---

## Testing

### Testing Best Practices
- Test files mirror source file structure
- Use descriptive test names explaining the scenario
- Follow **Given/When/Then** pattern in test methods
- Use `TestHelpers` for common setup code
- Mock external dependencies using protocols
- Aim for comprehensive test coverage of business logic

---

## View Templates (Leaf)

### Template Structure
- Always use `#extend("layout"):` with colon for layout extension
- Use `#export("title", "Page Title")` for inline exports
- Use `#export("content"):` for block content exports
- **ONLY** use `#export` within extend blocks, never `#set`
- Always close block exports with `#endexport`
- Always close extends with `#endextend`
- Use `#if(condition):` with `#endif` for conditionals
- Use `#for(item in items):` with `#endfor` for loops
- Use `#(variableName)` for variable interpolation

### Template Best Practices
- Keep template hierarchy consistent with `layout.leaf` as base
- Place page-specific CSS in dedicated sections
- Use consistent naming for template variables
- Follow BEM naming convention for CSS classes
- Keep templates DRY using partials

---

## Database (Fluent ORM)

### Database Patterns
- Use `@ID` property wrapper for primary keys
- Use `@Field` for standard model properties
- Use `@Parent`/`@Children` for relationships
- Use `@Timestamp` for created/updated timestamps
- Use migrations for all schema changes
- Include down migrations for reversibility
- Use meaningful names for foreign key constraints
- Add indexes for frequently queried fields
- Use soft deletes with `@SoftDelete` where appropriate

### Query Optimization
- Use `QueryBuilder` for complex queries
- Use `transaction(_:)` for atomic operations
- Implement efficient joins to avoid N+1 queries
- Use eager loading for related data

---

## API Design

### RESTful API Principles
- Use plural nouns for resource endpoints
- Follow standard HTTP methods (GET, POST, PUT, DELETE)
- Return appropriate HTTP status codes
- Include detailed error information in response body
- Version APIs appropriately
- Use consistent request/response formats

---

## Security

### Security Best Practices
- Use environment variables for sensitive configuration
- Implement rate limiting for public endpoints
- Validate and sanitize all user input
- Use secure headers in all responses
- Follow principle of least privilege
- Use JWT for stateless authentication
- Implement CSRF protection for web forms

---

## Performance

### Performance Standards
- Use `async/await` for concurrent operations
- Implement caching where appropriate (Redis with in-memory fallback)
- Optimize database queries and eliminate N+1 problems
- Use pagination for large result sets
- Profile and optimize slow endpoints
- Monitor cache hit rates and performance metrics

---

## Configuration

### Configuration Management
- Use environment variables for all configuration
- Provide sensible defaults for optional settings
- Document all configuration options in README
- Handle missing configuration gracefully
- Use type-safe configuration access patterns

---

## Vapor Framework Patterns

### Framework Usage
- Use Vapor's built-in dependency injection via `app.services`
- Register routes in `configure.swift` using route collections
- Use Fluent for all database operations
- Use Leaf for server-side rendering
- Use `Content` protocol for request/response models
- Use `async/await` with all Request handlers
- Use Vapor's built-in middleware system
- Use `Environment` for configuration management
- Use `app.logger` for all logging operations
- Use Vapor's authentication system

---

## View Contexts

### View Context Patterns
- Create dedicated view context struct for each Leaf template
- Place all view contexts in `Sources/App/DTOs/ViewContexts/`
- View context names must end with `ViewContext`
- All view contexts must conform to `Content` protocol
- Include `BaseViewContext` for common properties
- Name contexts after their corresponding template
- Document all properties with `///` comments

### View Context Organization
- One view context per file
- Import only necessary modules
- Group related properties together
- Place computed properties after stored properties
- Place initializers after properties
- Use extensions for helper methods
- Keep contexts focused and single-purpose

---

## Bandera Architecture

### Application-Specific Patterns
- Use `FeatureFlagService` for flag management
- Use `WebSocketService` for real-time updates
- Use repository pattern for data access abstraction
- Use service layer for business logic
- Use DTOs for API requests/responses
- Create dedicated view contexts for each template
- Use JWT for authentication
- Use rate limiting for API protection
- Use environment-based configuration
- Implement health checks for monitoring

### Feature Flag Patterns
- Use `FeatureFlag` model for flag definitions
- Use `UserFeatureFlag` for user-specific overrides
- Use `FeatureFlagService` for all flag operations
- Use WebSocket for real-time flag updates
- Implement feature flag event tracking
- Use Redis caching for flag performance
- Use typed feature flag values
- Implement flag validation logic
- Maintain feature flag audit logs

---

## Development Workflow

### Development Best Practices
- Use `restart.sh` script to restart the application
- Always kill existing processes before starting new ones
- Use development commands for debugging (`reset-admin`, `reset-password`)
- Remember default credentials: `admin@example.com` / `password`
- Check `/dev/users` to see available user accounts
- Use safe server termination with PID-based process killing

### Safe Server Management
- Use `lsof -i :<port>` to identify specific server PID
- Use `kill <PID>` for normal process termination
- Use `kill -9 <PID>` only when normal termination fails
- **NEVER** use generic commands like `pkill App` that can affect other applications
- Always verify correct process with `ps -p <PID>` before termination

---

## Action Items Management

### Task Tracking
- Check `ACTION_ITEMS.md` before starting new work
- Update `ACTION_ITEMS.md` when completing tasks
- Reference action items when discussing priorities
- Add new items when identifying technical debt
- Organize work by priority levels defined in action items
- Update progress percentages for major completions
- Keep `ACTION_ITEMS.md` current with today's date
- Break large items into measurable tasks

---

## Dependency Management

### Dependency Best Practices
- Specify exact versions in `Package.swift`
- Document third-party dependencies in README
- Keep dependencies updated and secure
- Minimize total number of dependencies
- Use dependency injection for testability
- Use protocols for service abstractions 