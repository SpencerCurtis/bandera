# Bandera Feature Flag Service - Cursor Rules

# File Organization
rule "Organize Swift files into appropriate directories" {
  description = "Keep Swift files organized in the correct directories based on their role"
  patterns = [
    "Controllers should be in Sources/App/Controllers/",
    "Models should be in Sources/App/Models/",
    "Repositories should be in Sources/App/Repositories/",
    "Services should be in Sources/App/Services/",
    "Middleware should be in Sources/App/Middleware/",
    "DTOs should be in Sources/App/DTOs/",
    "View templates should be in Resources/Views/",
    "Tests should be in Tests/AppTests/"
  ]
}

# Naming Conventions
rule "Use consistent naming conventions" {
  description = "Follow Swift naming conventions and project-specific patterns"
  patterns = [
    "Controller names should end with 'Controller'",
    "Repository names should end with 'Repository'",
    "Service names should end with 'Service'",
    "Protocol names for repositories should end with 'RepositoryProtocol'",
    "Protocol names for services should end with 'ServiceProtocol'",
    "View template files should use .leaf extension",
    "Test files should end with 'Tests'"
  ]
}

# Code Structure
rule "Maintain consistent code structure" {
  description = "Follow consistent patterns for code organization within files"
  patterns = [
    "Use MARK comments to separate major sections",
    "Place protocol conformances in extensions",
    "Group related properties and methods together",
    "Place private helpers in a private extension or at the bottom of the file",
    "Use // MARK: - for section headers"
  ]
}

# Error Handling
rule "Follow error handling patterns" {
  description = "Use consistent error handling throughout the application"
  patterns = [
    "Define custom errors in a dedicated Errors.swift file",
    "Custom errors should conform to AbortError",
    "Use async/await for asynchronous error handling",
    "Include recovery suggestions in error messages",
    "Log errors appropriately using app.logger"
  ]
}

# Documentation
rule "Maintain consistent documentation" {
  description = "Follow documentation standards throughout the codebase"
  patterns = [
    "Use /// for documentation comments",
    "Document all public APIs",
    "Include parameter descriptions for complex methods",
    "Add examples for non-obvious usage",
    "Keep README.md up to date with major changes"
  ]
}

# Testing
rule "Follow testing best practices" {
  description = "Maintain consistent testing patterns"
  patterns = [
    "Test files should mirror the structure of source files",
    "Use descriptive test names that explain the scenario",
    "Follow Given/When/Then pattern in test methods",
    "Use test helpers for common setup code",
    "Mock external dependencies in tests"
  ]
}

# View Templates
rule "Maintain consistent view template structure" {
  description = "Follow patterns for Leaf templates"
  patterns = [
    "Use #extend(\"layout\") for page templates",
    "Place page-specific CSS in a dedicated section",
    "Use consistent naming for template variables",
    "Follow BEM naming convention for CSS classes",
    "Keep templates DRY by using partials"
  ]
}

# Database
rule "Follow database best practices" {
  description = "Maintain consistent database patterns"
  patterns = [
    "Use migrations for schema changes",
    "Include down migrations for reversibility",
    "Use meaningful names for foreign key constraints",
    "Add indexes for frequently queried fields",
    "Use soft deletes where appropriate"
  ]
}

# API Design
rule "Maintain consistent API design" {
  description = "Follow RESTful API design principles"
  patterns = [
    "Use plural nouns for resource endpoints",
    "Follow standard HTTP methods (GET, POST, PUT, DELETE)",
    "Return appropriate HTTP status codes",
    "Include error details in response body",
    "Version APIs appropriately"
  ]
}

# Security
rule "Follow security best practices" {
  description = "Maintain consistent security patterns"
  patterns = [
    "Use environment variables for sensitive configuration",
    "Implement rate limiting for public endpoints",
    "Validate and sanitize user input",
    "Use secure headers in responses",
    "Follow principle of least privilege"
  ]
}

# Performance
rule "Maintain performance standards" {
  description = "Follow performance best practices"
  patterns = [
    "Use async/await for concurrent operations",
    "Implement caching where appropriate",
    "Optimize database queries",
    "Use pagination for large result sets",
    "Profile and optimize slow endpoints"
  ]
}

# Configuration
rule "Follow configuration patterns" {
  description = "Maintain consistent configuration handling"
  patterns = [
    "Use environment variables for configuration",
    "Provide sensible defaults for optional configuration",
    "Document all configuration options",
    "Handle missing configuration gracefully",
    "Use type-safe configuration access"
  ]
}

# Dependency Management
rule "Follow dependency management best practices" {
  description = "Maintain consistent dependency handling"
  patterns = [
    "Specify exact versions in Package.swift",
    "Document third-party dependencies in README",
    "Keep dependencies up to date",
    "Minimize number of dependencies",
    "Use dependency injection"
  ]
}

# Framework and Architecture
rule "Follow Vapor framework patterns" {
  description = "Maintain consistent Vapor framework usage throughout the application"
  patterns = [
    "Use Vapor's built-in dependency injection via app.services",
    "Register routes in configure.swift using route collections",
    "Use Fluent for database operations",
    "Use Leaf for server-side rendering",
    "Use Content protocol for request/response models",
    "Use async/await with Request handlers",
    "Use Vapor's built-in middleware system",
    "Use Environment for configuration",
    "Use app.logger for logging",
    "Use Vapor's authentication system"
  ]
}

rule "Follow Leaf template patterns" {
  description = "Maintain consistent Leaf template structure and usage"
  patterns = [
    "Use #extend(\"layout\") for template inheritance",
    "Use #export(\"content\") for page content",
    "Use ViewContext for passing data to templates",
    "Use #if/#else/#endif for conditional rendering",
    "Use #for loops for iterating over collections",
    "Use partials for reusable components",
    "Use consistent variable naming in templates",
    "Use Tailwind CSS for styling",
    "Use dark mode support in templates",
    "Use responsive design patterns"
  ]
}

rule "Follow Fluent ORM patterns" {
  description = "Maintain consistent database access patterns using Fluent"
  patterns = [
    "Use @ID property wrapper for primary keys",
    "Use @Field for model properties",
    "Use @Parent/@Children for relationships",
    "Use @Timestamp for created/updated timestamps",
    "Use Migrations for schema changes",
    "Use QueryBuilder for complex queries",
    "Use Model protocol for database entities",
    "Use soft deletes with @SoftDelete",
    "Use ModelMiddleware for model hooks",
    "Use transaction(_:) for atomic operations"
  ]
}

# Application Architecture
rule "Follow Bandera architectural patterns" {
  description = "Maintain consistent application architecture specific to Bandera"
  patterns = [
    "Use feature flag service for managing flags",
    "Use WebSocket service for real-time updates",
    "Use repository pattern for data access",
    "Use service layer for business logic",
    "Use DTOs for API requests/responses",
    "Use ViewContext for template data",
    "Use JWT for authentication",
    "Use rate limiting for API endpoints",
    "Use environment-based configuration",
    "Use health checks for monitoring"
  ]
}

rule "Follow feature flag patterns" {
  description = "Maintain consistent feature flag implementation"
  patterns = [
    "Use FeatureFlag model for flag definition",
    "Use UserFeatureFlag for user overrides",
    "Use FeatureFlagService for flag operations",
    "Use WebSocket for real-time flag updates",
    "Use feature flag events for tracking changes",
    "Use feature flag caching for performance",
    "Use typed feature flag values",
    "Use feature flag validation",
    "Use feature flag audit logging",
    "Use feature flag documentation"
  ]
} 

rule "Follow development workflow best practices" {
  description = "Maintain consistent development workflow for Bandera project"
  patterns = [
    "Use the restart.sh script to restart the application",
    "Kill existing processes before starting a new one",
    "Reset passwords with dev commands when needed",
    "Use development routes for efficient debugging",
    "Utilize the reset-admin command for admin password issues",
    "Remember default credentials: admin@example.com / password",
    "Use pkill -9 App || true to ensure port 8080 is available",
    "Run pkill -9 App || true && swift run to restart the app in one command",
    "Check /dev/users to see all available user accounts",
    "Use reset-password command for any user password issues"
  ]
}

rule "Safe server process termination" {
  description = "Use only PID-based process termination to avoid killing unrelated applications"
  patterns = [
    "Always use `lsof -i :<port>` to identify the specific PID of the Vapor server",
    "Use `kill <PID>` for normal termination of the identified process",
    "Use `kill -9 <PID>` only when normal termination fails",
    "Never use generic commands like `pkill App` or `pkill Run` that can terminate multiple apps",
    "For scripts, store and validate PIDs before terminating processes",
    "Use process name identification only for PID discovery, never for direct termination",
    "Always verify the correct process before termination with `ps -p <PID>`",
    "Document server termination procedures in README.md"
  ]
} 